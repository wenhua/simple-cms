(function() {
  var blue, client, done, finish_him, fs, green, grey, log, path, print, red, reset, start, tests, timeout, uncaught, yellow, _,
    _this = this;

  start = new Date;

  log = console.log;

  _ = require('underscore');

  fs = require('fs');

  path = require('path');

  client = require('./client');

  print = function() {
    return process.stdout.write.apply(process.stdout, arguments);
  };

  timeout = function(func, time) {
    return setTimeout(time, func);
  };

  grey = "\033[0;90m";

  red = "\033[0;31m";

  green = "\033[0;32m";

  yellow = "\033[0;33m";

  blue = "\033[0;34m";

  reset = "\033[0m";

  tests = {};

  done = {};

  uncaught = [];

  this.run_dir = function(dir) {
    return _this.add_dir(dir, function() {
      return _this.run();
    });
  };

  this.add_dir = function(dir, cb) {
    return fs.readdir(dir, function(err, files) {
      var f, p, _i, _len;
      if (err) {
        throw err;
      } else {
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          f = files[_i];
          if (f.match(/\.coffee$/)) {
            p = path.join(dir, f);
            if (p !== module.parent.filename) _this.add(p);
          }
        }
        return cb();
      }
    });
  };

  this.add = function(p) {
    var file, test, title, _ref, _results;
    file = path.basename(require.resolve(p));
    _ref = require(p).tests;
    _results = [];
    for (title in _ref) {
      test = _ref[title];
      _results.push((function(title, test) {
        var full_title;
        full_title = file + ': ' + title;
        tests[full_title] = test;
        return test.t = {
          title: title,
          file: file,
          full_title: full_title,
          expected: {},
          waits: {},
          passed: {},
          failed: {},
          client: client,
          all_passed: function() {
            return _(this.failed).isEmpty() && _(this.expected).isEmpty();
          },
          _reached: function(key) {
            if (this.expected[key]) {
              delete this.expected[key];
              return this.end_check();
            }
          },
          reached: function() {
            return this.pass.apply(this, arguments);
          },
          pass: function(key) {
            this.passed[key] = true;
            return this._reached(key);
          },
          fail: function(key, info) {
            if (info == null) info = {};
            this.failed[key] = info;
            return this._reached(key);
          },
          equal: function(key, actual, expected) {
            if (actual !== expected) {
              return this.fail(key, {
                type: 'equal',
                actual: actual,
                expected: expected
              });
            } else {
              return this.pass(key);
            }
          },
          matches: function(key, actual, regex) {
            if (!actual.match(regex)) {
              return this.fail(key, {
                type: 'matches',
                actual: actual,
                regex: regex
              });
            } else {
              return this.pass(key);
            }
          },
          ok: function(key, value) {
            if (!!!value) {
              return this.fail(key, {
                type: 'ok'
              });
            } else {
              return this.pass(key);
            }
          },
          expect: function() {
            var a, _i, _len, _results2;
            _results2 = [];
            for (_i = 0, _len = arguments.length; _i < _len; _i++) {
              a = arguments[_i];
              _results2.push(this.expected[a] = true);
            }
            return _results2;
          },
          wait: function(ms) {
            var id,
              _this = this;
            id = timeout(ms, function() {
              delete _this.waits[id];
              return _this.end_check();
            });
            return this.waits[id] = true;
          },
          end_check: function() {
            if (!done[this.full_title]) {
              if ((this.ran != null) && (_(this.expected).isEmpty() || _(this.waits).isEmpty())) {
                return this.end();
              }
            }
          },
          end: function() {
            var k, v, _ref2;
            _ref2 = this.waits;
            for (k in _ref2) {
              v = _ref2[k];
              clearInterval(k);
            }
            done[this.full_title] = this;
            if (_(done).size() === _(tests).size()) return finish_him();
          }
        };
      })(title, test));
    }
    return _results;
  };

  this.run = function() {
    var full_title, test, _results;
    _results = [];
    for (full_title in tests) {
      test = tests[full_title];
      _results.push((function(full_title, test) {
        var t;
        t = test.t;
        try {
          test(t);
        } catch (e) {
          t.error = e;
          t.end();
        }
        t.ran = true;
        return t.end_check();
      })(full_title, test));
    }
    return _results;
  };

  finish_him = function() {
    var e, errors, failed, full_title, i, line, passed, test, timedout, _fn, _i, _len;
    line = ((function() {
      var _results;
      _results = [];
      for (i = 1; i <= 40; i++) {
        _results.push('-');
      }
      return _results;
    })()).join('');
    log('');
    passed = 0;
    failed = 0;
    timedout = 0;
    errors = 0;
    _fn = function(full_title, test) {
      var k, t, v, _ref, _ref2, _ref3;
      t = done[full_title];
      if (!t.all_passed() || t.error) {
        log(full_title);
        log(line);
        _ref = t.passed;
        for (k in _ref) {
          v = _ref[k];
          passed++;
          log("" + green + "✔" + reset + " " + k);
        }
        _ref2 = t.failed;
        for (k in _ref2) {
          v = _ref2[k];
          failed++;
          log("" + red + "✖ " + k + " (failed '" + v.type + "')" + reset);
          if (v.type === 'equal') {
            log("Expected vs " + red + "actual" + reset + ":");
            log(v.expected);
            log(red + v.actual + reset);
          } else if (v.type === 'matches') {
            log("Regex vs " + red + "actual" + reset + ":");
            log(v.regex);
            log(red + v.actual + reset);
          }
        }
        _ref3 = t.expected;
        for (k in _ref3) {
          v = _ref3[k];
          timedout++;
          log("" + red + "✖ " + k + " (not reached)" + reset);
        }
        if (t.error) {
          errors++;
          log("" + red + "✖ Error:" + reset);
          log(t.error.stack);
        }
        return log('');
      }
    };
    for (full_title in tests) {
      test = tests[full_title];
      _fn(full_title, test);
    }
    if (uncaught.length > 0) {
      log("" + uncaught.length + " Uncaught error(s):");
      for (_i = 0, _len = uncaught.length; _i < _len; _i++) {
        e = uncaught[_i];
        log(e.stack);
      }
      log('');
    }
    log(line + line);
    if (failed === 0 && timedout === 0 && errors === 0 && uncaught.length === 0) {
      print("" + green + "All passing" + reset + " | ");
    } else {
      if (failed > 0) print("" + red + failed + " fail(s)" + reset + " | ");
      if (timedout > 0) {
        print("" + red + timedout + " not reached" + reset + " | ");
      }
      if (errors > 0) print("" + red + errors + " error(s)" + reset + " | ");
      if (uncaught.length > 0) {
        print("" + red + uncaught.length + " uncaught error(s)" + reset + " | ");
      }
    }
    print("" + (_(tests).size()) + " tests | ");
    log("" + (new Date - start) + " ms\n");
    return process.exit();
  };

  process.on('uncaughtException', function(err) {
    uncaught.push(err);
    throw err;
  });

}).call(this);
